% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gradient.R
\name{GenD}
\alias{GenD}
\title{Computation of derivative matrices with parallel capabilities}
\usage{
GenD(
  FUN,
  x,
  deriv.order = 1L,
  side = 0,
  acc.order = 2,
  h = (abs(x) + (x == 0)) * .Machine$double.eps^(1/(deriv.order + acc.order)),
  h0 = NULL,
  control = list(),
  f0 = NULL,
  cores = 1,
  load.balance = TRUE,
  func = NULL,
  report = 1L,
  ...
)
}
\arguments{
\item{FUN}{A function returning a numeric scalar or a vector.
If the function returns a vector, the output will be is a Jacobian.
If instead of \code{FUN}, \code{func} is passed, as in \code{numDeriv::grad},
it will be reassigned to \code{FUN} with a warning.}

\item{x}{Numeric vector or scalar: point at which the derivative is estimated.
\code{FUN(x)} must return a finite value.}

\item{deriv.order}{Integer indicating the derivative order,
\eqn{\mathrm{d}^m / \mathrm{d}x^m}{d^m/dx^m}.}

\item{side}{Integer scalar or vector indicating difference type:
\code{0} for central, \code{1} for forward, and \code{-1} for backward differences.
Central differences are recommended unless computational cost is prohibitive.}

\item{acc.order}{Integer specifying the desired accuracy order.
The error typically scales as \eqn{O(h^{\mathrm{acc.order}})}{O(h^acc.order)}.}

\item{h}{Numeric scalar, vector, or character specifying the step size for the numerical
difference. If character (\code{"CR"}, \code{"CRm"}, \code{"DV"}, or \code{"SW"}),
calls \code{gradstep()} with the appropriate step-selection method.
Must be length 1 or match \code{length(x)}.}

\item{h0}{Numeric scalar of vector: initial step size for automatic search with
\code{gradstep()}.}

\item{control}{A named list of tuning parameters passed to \code{gradstep()}.}

\item{f0}{Optional numeric scalar or vector: if provided and applicable, used
where the stencil contains zero (i.e. \code{FUN(x)} is part of the sum)
to save time.
TODO: Currently ignored.}

\item{cores}{Integer specifying the number of parallel processes to use. Recommended
value: the number of physical cores on the machine minus one.}

\item{load.balance}{Logical: if \code{TRUE}, disables pre-scheduling for \code{mclapply()}
or enables load balancing with \code{parLapplyLB()}.}

\item{func}{Deprecated; for \code{numDeriv::grad()} compatibility only.}

\item{report}{Integer: if \code{0}, returns a gradient without any attributes; if \code{1},
attaches the step size and its selection method: \code{2} or higher, attaches the full
diagnostic output (overrides \code{diagnostics = FALSE} in \code{control}).}

\item{...}{Additional arguments passed to \code{FUN}.}
}
\value{
Depends on the output of \code{FUN}. If \code{FUN} returns a scalar:
returns a gradient vector matching the length of \code{x}. If \code{FUN} returns a vector:
returns a Jacobian matrix with dimensions \code{length(FUN(x)), length(x)}.
Unlike the output of \code{numDeriv::grad} and \code{numDeriv::jacobian},
this output preserves the names of \code{x} and \code{FUN(x)}.
}
\description{
Numerical derivatives arranged into a generic matrix that can be processed
by \code{\link[=Grad]{Grad()}} and \code{\link[=Jacobian]{Jacobian()}} or used independently. Supports mixed orders
of derivation and arbitrary accuracies and sides for different coordinates
of the argument vector.
}
\details{
For computation of Jacobians, use \code{Jacobian} or \code{Grad}. These two functions
are equivalent, but using \code{Grad} for vector-valued returns will produce a warning.

If the step size is too large, the slope of the secant poorly estimates the derivative;
if it is too small, it leads to numerical instability due to the function value rounding.

The optimal step size for one-sided differences typically approaches Mach.eps^(1/2)
to balance the Taylor series truncation error with the rounding error due to storing
function values with limited precision. For two-sided differences, it is proportional
to Mach.eps^(1/3). However, selecting the best step size typically requires knowledge
of higher-order derivatives, which may not be readily available. Future releases
will allow character arguments to invoke automatic data-driven step-size selection.

The use of \code{f0} can reduce computation time similar to the use of \code{f.lower}
and \code{f.upper} in \code{uniroot()}.
}
\seealso{
\code{\link[=gradstep]{gradstep()}} for automatic step-size selection.
}
